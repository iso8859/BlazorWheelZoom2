@using BlazorSimpleSVG
@using Microsoft.JSInterop
@using System.Threading;
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<div @ref="divElement" style="position:relative;width:@Width;height:@Height;"
     @onpointerdown=PointerDown @onpointerdown:preventDefault @onpointerdown:stopPropagation
     @onpointerup=PointerUp @onpointerup:preventDefault @onpointerup:stopPropagation
     @oncontextmenu="()=> { }" @oncontextmenu:preventDefault
     @onpointermove=PointerMove @onpointermove:preventDefault
     @onwheel=Wheel @onwheel:stopPropagation @onwheel:preventDefault>

    @{
        Objects = new List<SVGObject>();
        if (Image != null)
            Objects.Add(Image);
        if (RectangleList != null)
            Objects.AddRange(RectangleList);
        if (drawingRect != null)
            Objects.Add(drawingRect);
    }
    <SimpleSVG SvgId="bwz" Objects="@Objects" Context="@Context" Width="100%" Height="100%" />
</div>

@code
{
    ElementReference divElement;

    [Parameter]
    public string ImageUri { get; set; }
    [Parameter]
    public string Width { get; set; } = "100px";
    [Parameter]
    public string Height { get; set; } = "100px";
    [Parameter]
    public EventCallback<SVGRectangle> NewRectangle { get; set; }
    [Parameter]
    public SVGRectangle NewRectangleTemplate { get; set; } = new SVGRectangle() { color = "red", fill = "lightgray", fill_opacity = "50%" };
    [Parameter]
    public List<SVGRectangle> RectangleList { get; set; }
    [Parameter]
    public EventCallback<SVGContext> ContextChanged { get; set; }

    SVGContext Context = new SVGContext();
    List<SVGObject> Objects = new List<SVGObject>();
    SVGImage Image;
    SVGRectangle drawingRect;

    protected override void OnInitialized()
    {
        Context.zoom = 1; // The zoom must start at 1 so we can determine the image size
        Image = new SVGImage() { id = "img1", href = ImageUri };
        Objects.Add(Image);
        drawingRect = new SVGRectangle() { visible = false };
        Objects.Add(drawingRect);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await GetSizesAsync();
            StateHasChanged();
        }
    }

    private IJSObjectReference module;

    public Task ContextHasChangedAsync()
    {
        return ContextChanged.InvokeAsync(Context);
    }

    // Use this method if you want to change the image
    Timer timer;
    public async Task RefreshAsync(string img)
    {
        if (ImageUri != img)
        {
            ImageUri = img;
            Context.viewSize = null;
            await ContextHasChangedAsync();
            Image.href = ImageUri;
            if (timer != null)
                await timer.DisposeAsync();
            timer = new Timer(async (e) => {
                await InvokeAsync(CheckSizeAsync);
            }, null, 250, 250);
        }
        await InvokeAsync(StateHasChanged);
    }

    public async Task CheckSizeAsync()
    {
        if (await GetSizesAsync())
        {
            await ContextHasChangedAsync();
            if (timer != null)
                await timer.DisposeAsync();
            timer = null;
        }
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        if (module != null)
            await module.DisposeAsync();
        module = null;
    }

    public async Task LoadJSModule()
    {
        if (module == null)
            module = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./_content/BlazorWheelZoom2/scripts.js");
    }

    public async Task<bool> GetSizesAsync()
    {
        if (Context.viewSize == null)
        {
            await LoadJSModule();
            var image = await module.InvokeAsync<string>("GetBoundingClientRect", Image.id);
            //Console.WriteLine(image);
            var jimage = System.Text.Json.JsonDocument.Parse(image);
            // Always left=0, top=0 => adjust right and bottom
            // Will return 0 width and height if image is not loaded
            Image.rect = new rect(); // To "unset" width and height
            Image.rect.left = Image.rect.top = 0;
            double width = jimage.RootElement.GetProperty("width").GetDouble() / Context.zoom;
            double height = jimage.RootElement.GetProperty("height").GetDouble() / Context.zoom;
            if (width != 0 && height != 0) // If null the image is not loaded yet, retry later
            {
                Image.rect.width = width;
                Image.rect.height = height;
                var svg = System.Text.Json.JsonDocument.Parse(await module.InvokeAsync<string>("GetBoundingClientRect", "bwz"));
                Context.viewSize = new rect()
                {
                    left = svg.RootElement.GetProperty("left").GetDouble(),
                    top = svg.RootElement.GetProperty("top").GetDouble(),
                    right = svg.RootElement.GetProperty("right").GetDouble(),
                    bottom = svg.RootElement.GetProperty("bottom").GetDouble()
                };
                Context.areaSize = new rect(0, 0, Image.rect.width, Image.rect.height);
                // Console.WriteLine($"SVG size = {Context.viewSize.left.ToStringInvariant()};{Context.viewSize.top.ToStringInvariant()};{Context.viewSize.right.ToStringInvariant()};{Context.viewSize.bottom.ToStringInvariant()}");
                await ContextHasChangedAsync();
            }
        }
        bool result = Context.viewSize != null;
        //Console.WriteLine($"GetSizesAsync = {result}");
        return result;
    }

    //[JSInvokable]
    //public static Task ImageLoaded()
    //{
    //    return GetSizesAsync();
    //}


    async Task Wheel(WheelEventArgs e)
    {
        if (await GetSizesAsync())
        {
            if (e.DeltaY > 0)
                Context.zoom /= 1.1;
            else if (e.DeltaY < 0)
                Context.zoom *= 1.1;
            Context.zoom = Math.Max(0.1, Math.Min(10, Context.zoom));
            Context.x_offset = Context.Clip(Context.x_offset, Context.viewSize.width - Context.Size(Image.rect.width));
            Context.y_offset = Context.Clip(Context.y_offset, Context.viewSize.height - Context.Size(Image.rect.height));
            await ContextHasChangedAsync();
            StateHasChanged();
        }
    }

    long mouseDown = -1;
    double mouseDownX, mouseDownY;
    double mouseDownImageX, mouseDownImageY;

    async Task PointerDown(PointerEventArgs e)
    {
        if (await GetSizesAsync())
        {
            if (mouseDown == -1)
            {
                if (e.Button == 0 || e.Button == 2)
                {
                    mouseDown = e.Button;
                    mouseDownX = e.OffsetX;
                    mouseDownY = e.OffsetY;
                    mouseDownImageX = Context.x_offset;
                    mouseDownImageY = Context.y_offset;
                    await LoadJSModule();
                    await module.InvokeVoidAsync("capturePointer", divElement, e.PointerId);
                }
                if (e.Button == 2)
                {
                    drawingRect.rect.left = Context.ScreenToViewX(e.OffsetX);
                    drawingRect.rect.top = Context.ScreenToViewY(e.OffsetY);
                    drawingRect.rect.right = drawingRect.rect.left + 1;
                    drawingRect.rect.bottom = drawingRect.rect.top + 1;
                    drawingRect.color = NewRectangleTemplate.color;
                    drawingRect.fill = NewRectangleTemplate.fill;
                    drawingRect.fill_opacity = NewRectangleTemplate.fill_opacity;
                    drawingRect.visible = true;

                    StateHasChanged();
                }
            }
            else
                await PointerMove(e);
        }
    }

    async Task PointerUp(PointerEventArgs e)
    {
        //Console.WriteLine("PointerUp {0}", System.Text.Json.JsonSerializer.Serialize(e));
        if (mouseDown == 2)
        {
            if (NewRectangle.HasDelegate)
                await NewRectangle.InvokeAsync(drawingRect);
            Objects.Remove(drawingRect);
            drawingRect = new SVGRectangle() { visible = false };
            Objects.Add(drawingRect);
        }
        if (mouseDown == 0 || mouseDown == 2)
        {
            mouseDown = -1;
            await LoadJSModule();
            await module.InvokeVoidAsync("releasePointer", divElement, e.PointerId);
        }
    }

    async Task PointerMove(PointerEventArgs e)
    {
        if (await GetSizesAsync())
        {
            if (mouseDown == 0)
            {
                Context.x_offset = Context.Clip(mouseDownImageX + e.OffsetX - mouseDownX, Context.viewSize.width - Context.Size(Image.rect.width));
                Context.y_offset = Context.Clip(mouseDownImageY + e.OffsetY - mouseDownY, Context.viewSize.height - Context.Size(Image.rect.height));
                await ContextHasChangedAsync();
            }
            else if (mouseDown == 2)
            {
                drawingRect.rect.right = drawingRect.rect.left + Context.ScreenToViewX(mouseDownImageX + e.OffsetX - mouseDownX);
                drawingRect.rect.bottom = drawingRect.rect.top + Context.ScreenToViewY(mouseDownImageY + e.OffsetY - mouseDownY);
            }
            StateHasChanged();
        }
    }

}
