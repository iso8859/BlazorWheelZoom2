@using BlazorSimpleSVG
@using Microsoft.JSInterop
@using System.Drawing;
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<div @ref="divElement" style="position:relative;" 
     @onpointerdown=PointerDown @onpointerdown:preventDefault @onpointerdown:stopPropagation
     @onpointerup=PointerUp @onpointerup:preventDefault @onpointerup:stopPropagation
     @oncontextmenu="()=> { }" @oncontextmenu:preventDefault
     @onpointermove=PointerMove @onpointermove:preventDefault
     @onwheel=Wheel @onwheel:stopPropagation @onwheel:preventDefault>

    <SimpleSVG SvgId="bwz" Objects="@Objects" Context="@Context" Width="@Width" Height="@Height" />
</div>

@code
{
    ElementReference divElement;

    [Parameter]
    public string ImageUri { get; set; }
    [Parameter]
    public string Width { get; set; } = "100px";
    [Parameter]
    public string Height { get; set; } = "100px";

    SVGContext Context = new SVGContext();
    List<SVGObject> Objects = new List<SVGObject>();
    SVGImage Image;
    SVGRectangle svgRect;
    SVGRectangle drawingRect;

    protected override void OnInitialized()
    {
        Context.zoom = 1; // The zoom must start at 1 so we can determine the image size
        Image = new SVGImage() { id = "img1", href = ImageUri };
        Objects.Add(Image);
        drawingRect = new SVGRectangle() { visible = false };
        Objects.Add(drawingRect);

        SVGContext test = new SVGContext() { x_offset = -10, y_offset = -10 };
        double x = test.ScreenToViewX(5);
    }

    private IJSObjectReference module;
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            module = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./_content/BlazorWheelZoom2/scripts.js");
            var image = await module.InvokeAsync<string>("GetBoundingClientRect", Image.id);
            var jimage = System.Text.Json.JsonDocument.Parse(image);
            Image.right = jimage.RootElement.GetProperty("right").GetDouble();
            Image.bottom = jimage.RootElement.GetProperty("bottom").GetDouble();
            var svg = System.Text.Json.JsonDocument.Parse(await module.InvokeAsync<string>("GetBoundingClientRect", "bwz"));
            svgRect = new SVGRectangle()
            {
                left = svg.RootElement.GetProperty("left").GetDouble(),
                top = svg.RootElement.GetProperty("top").GetDouble(),
                right = svg.RootElement.GetProperty("right").GetDouble(),
                bottom = svg.RootElement.GetProperty("bottom").GetDouble()
            };
        }
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        if (module != null)
            await module.DisposeAsync();
    }

    Task Wheel(WheelEventArgs e)
    {
        if (e.DeltaY > 0)
            Context.zoom /= 1.1;
        else if (e.DeltaY < 0)
            Context.zoom *= 1.1;
        Context.zoom = Math.Max(0.1, Math.Min(10, Context.zoom));
        Context.x_offset = Context.Clip(Context.x_offset, (svgRect.right - svgRect.left) - Context.Size(Image.right));
        Context.y_offset = Context.Clip(Context.y_offset, (svgRect.bottom - svgRect.top) - Context.Size(Image.bottom));
        StateHasChanged();
        return Task.CompletedTask;
    }

    long mouseDown = -1;
    double mouseDownX, mouseDownY;
    double mouseDownImageX, mouseDownImageY;

    async Task PointerDown(PointerEventArgs e)
    {
        //Console.WriteLine("PointerDown {0}", System.Text.Json.JsonSerializer.Serialize(e));

        if (mouseDown == -1)
        {
            if (e.Button == 0 || e.Button == 2)
            {
                mouseDown = e.Button;
                mouseDownX = e.OffsetX;
                mouseDownY = e.OffsetY;
                mouseDownImageX = Context.x_offset;
                mouseDownImageY = Context.y_offset;
                await module.InvokeVoidAsync("capturePointer", divElement, e.PointerId);
            }
            if (e.Button == 2)
            {
                drawingRect.left = Context.ScreenToViewX(e.OffsetX);
                drawingRect.top = Context.ScreenToViewY(e.OffsetY);
                drawingRect.right = drawingRect.left + 1;
                drawingRect.bottom = drawingRect.top + 1;
                drawingRect.color = "red";
                drawingRect.fill = "lightgreen";
                drawingRect.fill_opacity = "50%";
                drawingRect.visible = true;

                StateHasChanged();
            }
        }
        else
            PointerMove(e);
    }

    async Task PointerUp(PointerEventArgs e)
    {
        //Console.WriteLine("PointerUp {0}", System.Text.Json.JsonSerializer.Serialize(e));
        if (mouseDown == 2)
        {
            drawingRect = new SVGRectangle() { visible = false };
            Objects.Add(drawingRect);
        }
        mouseDown = -1;
        await module.InvokeVoidAsync("releasePointer", divElement, e.PointerId);
    }

    void PointerMove(PointerEventArgs e)
    {

        if (mouseDown == 0)
        {
            Context.x_offset = Context.Clip(mouseDownImageX + e.OffsetX - mouseDownX, (svgRect.right - svgRect.left) - Context.Size(Image.right));
            Context.y_offset = Context.Clip(mouseDownImageY + e.OffsetY - mouseDownY, (svgRect.bottom - svgRect.top) - Context.Size(Image.bottom));
        }
        else if (mouseDown == 2)
        {
            drawingRect.right = drawingRect.left + Context.ScreenToViewX(mouseDownImageX + e.OffsetX - mouseDownX);
            drawingRect.bottom = drawingRect.top + Context.ScreenToViewY(mouseDownImageY + e.OffsetY - mouseDownY);
            //Console.WriteLine("PointerMove {0};{1};{2}", e.OffsetX - mouseDownX, Context.ScreenToViewX(e.OffsetX - mouseDownX), drawingRect);
        }
        StateHasChanged();
    }

}