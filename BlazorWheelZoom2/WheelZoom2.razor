@using BlazorSimpleSVG
@using Microsoft.JSInterop
@using System.Drawing;
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable

<div @ref="divElement" style="position:relative;"
     @onpointerdown=PointerDown @onpointerdown:preventDefault @onpointerdown:stopPropagation
     @onpointerup=PointerUp @onpointerup:preventDefault @onpointerup:stopPropagation
     @oncontextmenu="()=> { }" @oncontextmenu:preventDefault
     @onpointermove=PointerMove @onpointermove:preventDefault
     @onwheel=OnWheel @onwheel:stopPropagation @onwheel:preventDefault>

    <SimpleSVG SvgId="bwz" Objects="@Objects" Context="@Context" Width="@Width" Height="@Height" />
</div>

@code
{
    ElementReference divElement;

    [Parameter]
    public string ImageUri { get; set; }
    [Parameter]
    public string Width { get; set; } = "100px";
    [Parameter]
    public string Height { get; set; } = "100px";

    SVGContext Context = new SVGContext();
    List<SVGObject> Objects = new List<SVGObject>();
    SVGImage Image;
    SVGRectangle svgRect;
    SVGRectangle drawingRect;

    protected override void OnInitialized()
    {
        Context.zoom = 1; // The zoom must start at 1 so we can determine the image size
        Image = new SVGImage() { id = "img1", href = ImageUri };
        Objects.Add(Image);
        drawingRect = new SVGRectangle() { visible = false };
        Objects.Add(drawingRect);
    }

    private IJSObjectReference module;
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            module = await JSRuntime.InvokeAsync<IJSObjectReference>("import", "./_content/BlazorWheelZoom2/scripts.js");
            var image = await module.InvokeAsync<string>("GetBoundingClientRect", Image.id);
            var jimage = System.Text.Json.JsonDocument.Parse(image);
            Image.right = jimage.RootElement.GetProperty("right").GetDouble();
            Image.bottom = jimage.RootElement.GetProperty("bottom").GetDouble();
            var svg = System.Text.Json.JsonDocument.Parse(await module.InvokeAsync<string>("GetBoundingClientRect", "bwz"));
            svgRect = new SVGRectangle()
            {
                left = svg.RootElement.GetProperty("left").GetDouble(),
                top = svg.RootElement.GetProperty("top").GetDouble(),
                right = svg.RootElement.GetProperty("right").GetDouble(),
                bottom = svg.RootElement.GetProperty("bottom").GetDouble()
            };
        }
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        if (module != null)
            await module.DisposeAsync();
    }

    Task OnWheel(WheelEventArgs e)
    {
        if (e.DeltaY > 0)
            Context.zoom /= 1.1;
        else if (e.DeltaY < 0)
            Context.zoom *= 1.1;
        Context.zoom = Math.Max(0.1, Math.Min(10, Context.zoom));
        Context.x_offset = Context.Clip(Context.x_offset, (svgRect.right-svgRect.left) - Context.Size(Image.right));
        Context.y_offset = Context.Clip(Context.y_offset, (svgRect.bottom - svgRect.top) - Context.Size(Image.bottom));
        StateHasChanged();
        return Task.CompletedTask;
    }

    long mouseDown = -1;
    double mouseDownX, mouseDownY;
    double mouseDownImageX, mouseDownImageY;

    bool rectangle = false;
    async Task PointerDown(PointerEventArgs e)
    {
        if (e.Button == 0 || e.Button == 2)
        {
            mouseDown = e.Button;
            mouseDownX = e.ClientX;
            mouseDownY = e.ClientY;
            mouseDownImageX = Context.x_offset;
            mouseDownImageY = Context.y_offset;
            await module.InvokeVoidAsync("capturePointer", divElement, e.PointerId);
        }
        if (e.Button==2)
        {
            drawingRect.left = Context.ScreenToViewX(e.ClientX - svgRect.left);
            drawingRect.top = Context.ScreenToViewY(e.ClientY - svgRect.top);
            drawingRect.right = drawingRect.left + 1;
            drawingRect.bottom = drawingRect.top + 1;
            drawingRect.color = "red";
            drawingRect.fill = "lightgreen";
            drawingRect.fill_opacity = "50%";
            drawingRect.visible = true;
            StateHasChanged();
        }
    }

    async Task PointerUp(PointerEventArgs e)
    {
        if (mouseDown==2)
        {
            drawingRect = new SVGRectangle() { visible = false };
            Objects.Add(drawingRect);
        }
        mouseDown = -1;
        await module.InvokeVoidAsync("releasePointer", divElement, e.PointerId);
    }

    void PointerMove(PointerEventArgs e)
    {
        //double px = Context.ScreenToViewX(e.ClientX - svgRect.left);
        //double py = Context.ScreenToViewY(e.ClientY - svgRect.top);
        //Console.WriteLine($"{px};{py}");
        if (mouseDown == 0)
        {
            Context.x_offset = Context.Clip(mouseDownImageX + e.ClientX - mouseDownX, (svgRect.right - svgRect.left) - Context.Size(Image.right));
            Context.y_offset = Context.Clip(mouseDownImageY + e.ClientY - mouseDownY, (svgRect.bottom - svgRect.top) - Context.Size(Image.bottom));
        }
        else if (mouseDown == 2)
        {
            drawingRect.right = Context.ScreenToViewX(mouseDownImageX + e.ClientX - svgRect.left - mouseDownX - svgRect.left);
            drawingRect.bottom = Context.ScreenToViewY(mouseDownImageY + e.ClientY - svgRect.top - mouseDownY - svgRect.top);
        }
        StateHasChanged();
    }

}